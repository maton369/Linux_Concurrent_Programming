/*
 * 目的:
 *   fork() と wait() を組み合わせて、
 *     - 親プロセスと子プロセスが分岐すること
 *     - 親が子の終了を wait() で待てること（= 子の終了を回収できること）
 *   を観察するためのコードである。
 *
 * この版で新しく入った要素:
 *   - 子プロセス側で sleep(5) して「子がしばらく生き残る」状況を作る
 *   - 親プロセス側で wait(&status) して「子が終わるまで親が待つ」ことを保証する
 *
 * これにより、出力順序はほぼ確定する（※fork自体は非決定的だが wait が順序を作る）。
 *
 * 実行イメージ:
 *   1) 親が fork() → 子が生成される
 *   2) 子: "子プロセス" を出力し、5秒 sleep してから終了
 *   3) 親: wait() で子の終了を待つ（5秒待たされる）
 *   4) 親: 子の終了を回収した後で "親プロセス" を出力して終了
 *
 * 重要:
 *   wait() を入れる意義は「ゾンビプロセスを残さない」こと。
 *   親が子の終了ステータスを回収しないと、子は一時的にゾンビになる（終了したのに情報だけ残る）。
 */

#include <unistd.h>      /* fork(), getpid(), getppid(), sleep() など POSIX API */
#include <stdio.h>       /* printf() */
#include <sys/types.h>   /* pid_t などの型（fork戻り値を受けるなら使うのが自然） */
#include <sys/wait.h>    /* wait(), waitpid() の宣言 */

/*
 * main:
 *   親プロセスとして起動し、fork() により子プロセスを生成する。
 *   fork() の次の行から親と子が並行に進むが、このコードでは親が wait() することで
 *   出力の順序を「子 → 親」に寄せている。
 */
int main(void){

  /*
   * status:
   *   wait() が返す「子プロセスの終了ステータス」を受け取るための変数。
   *
   * wait(&status) は、子が終了すると status に情報を詰める。
   * その情報はビット列で、WIFEXITED/WEXITSTATUS などのマクロで解釈する。
   *
   * 例:
   *   if (WIFEXITED(status)) printf("exit=%d\n", WEXITSTATUS(status));
   *
   * 今回は「待てること」を観察するのが主目的なので、status を解釈していない。
   */
  int status;

  /*
   * if (fork() == 0) ... else ...
   *
   * fork() の戻り値:
   *   - 子プロセス側: 0
   *   - 親プロセス側: 子プロセスの PID（>0）
   *   - 失敗        : -1
   *
   * この書き方の意味:
   *   - if 側に入るのは「子」だけ（0だから）
   *   - else 側に入るのは「親」…が通常だが、失敗(-1)でも else に入るので注意
   *
   * 実務・教材としては、戻り値を変数に受けて 3分岐（失敗/子/親）する方が安全。
   * ただしここでは最小の分岐形として if(fork()==0) を使っている。
   */
  if (fork() == 0){

    /*
     * ここは「子プロセス側」だけが実行するブロック。
     *
     * 子プロセスの特徴:
     *   - 親と別PIDを持つ
     *   - 親とは別のスケジューリング単位（別プロセス）として動く
     *   - メモリ空間は論理的に分離される（ただしCOWで最初は共有に見える）
     */

    /*
     * printf:
     *   子プロセスであることを目視できるようラベルを出す。
     *
     * 出力順の注意:
     *   fork直後は親子が並行なので本来は順序が保証されないが、
     *   この後に親が wait() するため「親の表示は子の終了後」に固定されやすい。
     */
    printf("子プロセス\n");

    /*
     * sleep(5):
     *   子プロセスを 5 秒止める。
     *
     * これを入れる理由:
     *   - 子がすぐ終了してしまうと wait() の効果が観察しにくい
     *   - 親が wait() で「しっかり待たされる」様子を体感できる
     *
     * 観察方法:
     *   - 実行して「親プロセス」が 5 秒後に出ることを確認する
     *   - 別ターミナルで ps して子が生きている間の状態を見る
     */
    sleep(5);

    /*
     * 子プロセスはこのまま return 0 に到達して終了する。
     * 終了した瞬間、親が wait() していればすぐ回収される。
     */
  }
  else{

    /*
     * ここは「親プロセス側」が通常実行するブロック。
     *
     * wait(&status):
     *   - 子プロセスが終了するまで親プロセスをブロック（待機）させる
     *   - 子が終了したら、その終了ステータスを status に格納し、待機を解除する
     *
     * wait を入れる意義（超重要）:
     *   - 子が終了しても親が回収しないと、子は一時的に「ゾンビプロセス」になる
     *   - wait はそのゾンビを回収し、OSのプロセステーブルを綺麗にする
     *
     * 注意点:
     *   - 子が複数いる場合 wait は「どれか1つ」を回収する（対象を選べない）
     *   - 対象を選びたいなら waitpid(child_pid, ...) を使う
     *
     * ここでは子は1つだけなので wait(&status) で十分。
     */
    wait(&status);

    /*
     * 親プロセスの printf:
     *   wait() が戻った後（= 子の終了を確認し回収した後）に実行される。
     *
     * そのため実行結果はほぼ確実に
     *   子プロセス
     *   (5秒空く)
     *   親プロセス
     * となる。
     */
    printf("親プロセス\n");
  }

  /*
   * ここから下は「親も子も両方」が到達しうる場所だが、
   * このコードでは親子ともに if/else の最後まで来て return 0 に落ちる。
   *
   * ただし親は wait() の分だけ遅れてここに到達する。
   */

  /*
   * さらに観察を強化するなら:
   *   - 親子それぞれで PID/PPID を表示する
   *
   * 例（学習用）:
   *   printf("pid=%d ppid=%d\n", (int)getpid(), (int)getppid());
   *
   * 子側で ppid を見ると親PIDが出る。
   * 親が先に死ぬと ppid が init/systemd に変わるが、
   * このコードは親が wait してから終了するので変わりにくい（観察が安定する）。
   */

  /*
   * return 0:
   *   親も子も正常終了。
   *
   * 結果:
   *   - 子は sleep(5) の後に終了し、親が wait で回収する
   *   - 親は wait 解除後に出力して終了する
   */
  return 0;
}

/*
 * 実行例（このコードでは wait により順序がほぼ固定される）:
 *
 *   $ ./a.out
 *   子プロセス
 *   （ここで約5秒待つ）
 *   親プロセス
 *
 * 観察ポイント:
 *   - wait() があるため「親プロセス」が即座に出ない
 *   - wait() により子の終了が回収され、ゾンビが残りにくい
 *
 * 注意（fork失敗の扱い）:
 *   if(fork()==0) else の形だと fork が -1 のときも else に入る。
 *   本格的に書くなら 3分岐にして perror を入れるのが定石。
 */
