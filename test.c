/*
 * このプログラムのポイント:
 *   - execl() を呼ぶと「今動いているプロセスが、別プログラムに置き換わる」。
 *   - fork() のように“増える”のではなく、「変身（置換）」するイメージ。
 *
 * 具体的には:
 *   1) まず自分が printf でメッセージを出す
 *   2) execl("/usr/bin/cal", "cal", "1", "2020", (char*)0) を呼ぶ
 *   3) 成功した瞬間、このプロセスは cal コマンド（2020年1月のカレンダー表示）になり、
 *      元のプログラムの制御フローには「戻ってこない」
 *
 * 重要（forkとの違い）:
 *   - fork(): 親と子の「2プロセス」に増える（複製）
 *   - exec系(execl等): 同じPIDのまま「中身（実行ファイルとメモリ内容）」を置き換える
 *
 * 並行プログラミング観点での位置づけ:
 *   「親が fork() で子を作り、子が exec() で別プログラムになる」
 *   というのが UNIX のプロセス生成の王道パターンである。
 *
 * 注意（stdoutバッファ）:
 *   printf した直後に exec する場合、改行があるので端末ならflushされやすい。
 *   ただしリダイレクト時などはバッファが残る可能性があるので、
 *   確実に出したいなら fflush(stdout) を入れるのが安全。
 */

#include <stdio.h>   /* printf(), perror() など標準入出力 */
#include <unistd.h>  /* execl() など POSIX API */

/*
 * main:
 *   execl() を呼んだら基本的に戻ってこないので、
 *   「execl が失敗したときだけ」この main の後続行が実行される。
 *
 * ※学習用には int main(void) / return を明示するのが分かりやすい。
 */
int main(void){

  /*
   * まずは「これから cal に置き換わるよ」というメッセージを出す。
   *
   * 改行 \n があるため端末では通常すぐ表示されるが、
   * 出力が確実に見えるようにしたいなら fflush(stdout) を挟むことがある。
   */
  printf("cal 1 2020 に変身\n");

  /*
   * execl(path, arg0, arg1, ..., (char*)0)
   *
   * exec系の共通の意味:
   *   - 現在のプロセスのメモリ空間を、新しいプログラムで置き換える
   *   - 成功したら戻ってこない（戻るのは失敗時だけ）
   *   - PID は変わらない（同じプロセスのまま“中身だけ”変わる）
   *
   * execl の引数の意味:
   *   path:
   *     実行したいファイルのパス（ここでは /usr/bin/cal）
   *
   *   arg0:
   *     新しいプログラムが argv[0] として受け取る文字列
   *     慣習的にはコマンド名（ここでは "cal"）
   *
   *   arg1, arg2, ...:
   *     新しいプログラムの引数（ここでは "1", "2020"）
   *     つまり実質的に `cal 1 2020` を実行するのと同じ。
   *
   *   終端:
   *     引数列の最後は NULL ポインタで終える必要がある。
   *     Cの可変長引数なので、(char*)0 を書いて終端を明示している。
   *
   * 実行されるコマンドの等価表現:
   *   /usr/bin/cal 1 2020
   */
  execl("/usr/bin/cal", "cal", "1", "2020", (char *)0);

  /*
   * ここに到達するのは execl が失敗した場合だけ。
   *
   * 失敗の例:
   *   - /usr/bin/cal が存在しない（環境によっては /bin/cal など）
   *   - 実行権限がない
   *   - 引数が間違っている
   *
   * perror は errno を見て失敗理由を表示してくれる。
   * 実務では exec 失敗時は非0で終了するのが普通。
   */
  perror("execl failed");

  return 1;  /* 異常終了（execl が失敗したので 1 を返す） */
}

/*
 * 実行例（成功時）:
 *   $ ./a.out
 *   cal 1 2020 に変身
 *        2020年 1月
 *   日 月 火 水 木 金 土
 *             1  2  3  4
 *    5  6  7  8  9 10 11
 *   12 13 14 15 16 17 18
 *   19 20 21 22 23 24 25
 *   26 27 28 29 30 31
 *
 * 実行例（失敗時）:
 *   $ ./a.out
 *   cal 1 2020 に変身
 *   execl failed: No such file or directory
 *
 * 学習の次の一手:
 *   - fork() して子だけが execl する（親は wait する）
 *     → 「親が子プロセスを作り、子が別プログラムに変身する」UNIXの王道パターン。
 */
