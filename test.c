/*
 * 目的:
 *   fork() とプロセスの基本挙動を「観察」するための最小コードである。
 *
 *   元々は getpid() だけで「自分のPIDを表示」するだけだったが、
 *   ここでは fork() を 1 回呼ぶことで、
 *
 *     - 親プロセス（fork() を呼んだ側）
 *     - 子プロセス（fork() によって新しく作られる側）
 *
 *   の 2 つのプロセスが同じコードを同時に進むことを体験する。
 *
 * 重要:
 *   fork() は「スレッドを増やす」のではなく「プロセスを複製する」操作である。
 *   したがって、メモリ空間は分離される（ただし最初は Copy-on-Write で共有っぽく見える）。
 *
 * 観察結果としては、このプログラムを実行すると printf が 2 回走り、
 *   - 親のPID
 *   - 子のPID
 * がそれぞれ表示される。
 *
 * 今回の追加点:
 *   - fork() の戻り値を val に保存して表示することで、
 *     「親/子で fork() の戻り値が変わる」ことを直接観察できるようにしている。
 *
 * 注意:
 *   - printf の表示順は非決定的であり、毎回同じ順序になるとは限らない。
 *   - val の表示は「親では子PID」「子では 0」「失敗では -1」になる。
 */

#include <sys/types.h>   /* pid_t の型定義など。
                          *
                          * pid_t は「PIDを表すための専用型」。
                          * OSや環境によって内部表現（int相当かどうか等）が異なる可能性があるため、
                          * PIDを扱うときは int ではなく pid_t を使うのがPOSIX流である。
                          */

#include <unistd.h>      /* POSIX API:
                          * fork(), getpid(), getppid() などの宣言がある。
                          *
                          * fork(): プロセス複製
                          * getpid(): 自分のPID取得
                          * getppid(): 親のPID取得（子プロセス側の観察に便利）
                          */

#include <stdio.h>       /* printf() 用（標準入出力） */

/*
 * main:
 *   親プロセスとして起動し、fork() によって子プロセスも生成される。
 *   fork() 以降のコードは「親と子の両方」が実行する点が最大のポイント。
 *
 *   つまり「fork() を境に、制御フローが2本に分岐する」。
 *   ただし分岐の判定材料は fork() の戻り値であり、
 *   それを val に入れて観察するのが今回の狙い。
 */
int main(void){

  /*
   * pid_t val;
   *   fork() の戻り値（親子判別のキー）を保存するための変数。
   *
   * fork() の戻り値仕様（超重要）:
   *   - 親プロセス: 子プロセスのPID（>0）
   *   - 子プロセス: 0
   *   - 失敗       : -1（子は生成されない）
   *
   * 観察のコツ:
   *   - val==0 の行は「子プロセス」からの出力
   *   - val>0 の行は「親プロセス」からの出力
   *   - val==-1 が出たら fork に失敗（リソース不足など）
   */
  pid_t val;

  /*
   * val = fork();
   *
   * 実行直後に何が起きるか（概念図）:
   *
   *           fork()
   *             |
   *    +--------+---------+
   *    |                  |
   *    v                  v
   *  親プロセス         子プロセス
   *  val = 子PID        val = 0
   *  getpid() = 親PID   getpid() = 子PID
   *
   * ここで最重要なのは、
   *   fork() の「次の行」から親子が別々に実行を続けること。
   * つまり、この後の printf は「親でも子でも実行される」。
   */
  val = fork();

  /*
   * printf("forkの戻り値＝%d\n", val);
   *
   * 観察ポイント:
   *   - 親プロセス側:
   *       val は「子プロセスのPID」になる（例: 12346）
   *   - 子プロセス側:
   *       val は 0 になる
   *
   * つまり、同じ行の printf でも、親と子で出力内容が変わる。
   *
   * 注意（型とフォーマット）:
   *   pid_t が必ず int とは限らないため、厳密にはキャストして表示するのが安全。
   *   学習上は %d でも動く環境が多いが、移植性を意識するなら (int) を付ける。
   */
  printf("forkの戻り値＝%d\n", (int)val);

  /*
   * printf("プロセスid=%d\n", getpid());
   *
   * これも親と子で2回実行される。
   * getpid() の結果が異なるので、
   *   - 親PID
   *   - 子PID
   * が表示される。
   *
   * 観察の仕方:
   *   - 「forkの戻り値」と「プロセスid」を突き合わせる。
   *
   * 典型例（順序は変わる）:
   *   forkの戻り値＝12346   ← 親（val>0、子PIDが見えている）
   *   プロセスid=12345      ← 親のPID
   *   forkの戻り値＝0       ← 子（val==0）
   *   プロセスid=12346      ← 子のPID（親のvalと一致するはず）
   *
   * こうして「親が見ている子PID」と「子自身のPID」が一致することを確認できる。
   */
  printf("プロセスid=%d\n", (int)getpid());

  /*
   * ここから下は「親プロセス」と「子プロセス」が両方実行する。
   *
   * 今回のコードでは fork() の戻り値を出力しているため、
   *   - 親の出力
   *   - 子の出力
   * が混ざって見える。
   *
   * 非決定性（重要）:
   *   親子のどちらが先に printf を実行するかは保証されない。
   *   OSスケジューラがその瞬間にどちらを走らせるかで順序が変わる。
   *
   * さらに実務的な注意:
   *   親子が同じ stdout に同時に書き込むと、出力が入り混じる可能性がある。
   *   今回は行単位で短いので混ざりにくいが、長い文字列や複数printfだと混ざりやすい。
   */

  /*
   * getpid() / getppid() について補足:
   *   - getpid(): 自分のPID
   *   - getppid(): 親のPID
   *
   * 子プロセス側で getppid() を表示すると「親子関係」がさらに見える。
   * ただし、親が先に終了すると子の親は init/systemd に付け替わる（PPIDが変わる）場合がある。
   * これも fork の観察で面白いポイントになる。
   */

  /*
   * 注意（バッファリング）:
   *   stdout は端末に接続されていると「行バッファ」になりやすいが、
   *   リダイレクト（./a.out > out.txt）すると「フルバッファ」になりやすい。
   *
   * fork の直前に printf して改行が無い場合:
   *   - バッファの中身が fork で複製され、
   *   - 親と子がそれぞれ flush して
   *   - 同じ内容が2回出る
   * という現象が起こりうる。
   *
   * 今回は fork の後に printf しているのでこの事故は起きにくいが、
   * fork + 標準出力の組み合わせでは頻出の落とし穴である。
   */

  /*
   * エラー処理（学習としての次の一手）:
   *   val == -1 の場合 fork が失敗している。
   *   本来は perror("fork") して exit(1) するのが定石。
   *
   * 例（概念）:
   *   if (val < 0) { perror("fork"); return 1; }
   *
   * 今回は観察用の最小コードとして、あえて入れていない。
   */

  /*
   * return 0:
   *   正常終了。
   *   親も子もここに到達して、それぞれ独立に終了する。
   *
   * 重要:
   *   親が先に終了すると、子は「孤児プロセス」になり、
   *   systemd/init に回収されて PPID が変わることがある。
   *
   * そのため fork の学習では、
   *   - 親が wait() する（子の終了を回収する）
   * を入れるとプロセス管理がより理解しやすい。
   */
  return 0;
}

/*
 * 実行例（典型、ただし順序は毎回変わる）:
 *
 *   $ gcc -Wall -O2 pid.c -o pid
 *   $ ./pid
 *   forkの戻り値＝12346
 *   プロセスid=12345
 *   forkの戻り値＝0
 *   プロセスid=12346
 *
 * 観察ポイント:
 *   - forkの戻り値が 0 の行が「子」
 *   - forkの戻り値が >0 の行が「親」
 *   - 親側の val（子PID）と、子側の getpid() が一致する
 *   - 出力順は非決定的で変わりうる
 *
 * 次にやると理解が一気に深まる追加観察:
 *   - 子側で getppid() を表示（親PIDが見える）
 *   - 親側で wait(NULL) する（ゾンビ回収・順序制御が理解できる）
 */
