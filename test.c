/*
 * 目的:
 *   fork() とプロセスの基本挙動を「観察」するためのコードである。
 *
 *   ここでは fork() を使って
 *     - 親プロセス
 *     - 子プロセス
 *   の2つが「同じコード」を同時に実行し始めることを確認する。
 *
 * 今回のポイント（この版の構造）:
 *   - if (fork() == 0) ... else ... の形で、親と子で表示を分けている。
 *     → 「どっちが親でどっちが子か」をラベル付きで見分けやすくしている。
 *
 * 注意:
 *   - fork() の呼び出し後は、親と子が並行に進むため表示順は非決定的。
 *   - 出力先(stdout)のバッファリング状態によっては、fork前後のprintfで予期せぬ二重出力が起きうる。
 */

#include <unistd.h>      /* fork(), getpid(), getppid() など POSIX API の宣言 */
#include <stdio.h>       /* printf() */

/*
 * main:
 *   親プロセスとして起動し、fork() によって子プロセスを生成する。
 *   fork() の「次の行」から親子がそれぞれ実行を継続するのが本質。
 */
int main(void){

  /*
   * ここで fork() を呼ぶ。
   *
   * fork() の戻り値:
   *   親プロセス側: 子プロセスの PID（>0）
   *   子プロセス側: 0
   *   失敗        : -1
   *
   * if (fork() == 0) の意味:
   *   - 条件が真になるのは「子プロセス側」だけ（子は 0 を返すから）
   *   - 条件が偽になるのは「親プロセス側」だけ（親は子PID>0を返すから）
   *
   * したがって、この if/else は
   *   - 子プロセス: "子プロセス" と表示
   *   - 親プロセス: "親プロセス" と表示
   * という「親子分岐」を実現している。
   *
   * ただし重大な注意点:
   *   - fork() が失敗して -1 を返した場合も else 側（親プロセス扱い）に入ってしまう。
   *     つまりこの書き方だと「失敗時の検出」ができない。
   *   - 学習の次の段階では、fork() の戻り値を変数に入れて
   *       pid_t pid = fork();
   *       if (pid < 0) { ...失敗処理... }
   *       else if (pid == 0) { ...子... }
   *       else { ...親... }
   *     のように3分岐するのが定石。
   */
  if (fork() == 0){
    /*
     * ここは「子プロセス側」だけが実行する。
     *
     * 子プロセスとは:
     *   fork() によって新しく生成されたプロセス。
     *   親プロセスとは別PIDを持ち、OSから別の実行単位として扱われる。
     */
    printf("子プロセス\n");
  }
  else{
    /*
     * ここは「親プロセス側」が実行するのが通常。
     *
     * ただし fork() 失敗(-1) の場合もここに入る点に注意。
     * 失敗時は子が作られていないため、ここで「親プロセス」と出るのは誤解を招きうる。
     *
     * 失敗を正しく扱うには:
     *   pid = fork(); の戻り値を見て pid<0 を分岐させる必要がある。
     */
    printf("親プロセス\n");
  }

  /*
   * この時点でプロセスはいくつあるか?
   *   - fork() が成功していれば「親1 + 子1 = 合計2プロセス」が存在する。
   *   - fork() が失敗していれば「親だけ」であり合計1プロセスのまま。
   *
   * 重要:
   *   ここから下のコードは「親も子も両方が実行する」。
   *   つまり、return 0 も親と子がそれぞれ別々に到達して終了する。
   */

  /*
   * ここで PID を観察したい場合は本来こういう行を追加する:
   *   printf("pid=%d ppid=%d\n", (int)getpid(), (int)getppid());
   *
   * そうすると、
   *   - 親プロセス側: pid=親PID, ppid=シェル等
   *   - 子プロセス側: pid=子PID, ppid=親PID
   * が見えて「親子関係」がより明確になる。
   *
   * また、親が先に終了すると子の ppid が init/systemd に切り替わることがある。
   * これを確実に観察したい場合は sleep() を入れてタイミングを調整したり、
   * 逆に親で wait() して子を回収する（ゾンビ防止）などを行う。
   */

  /*
   * return 0:
   *   親も子もそれぞれ正常終了する。
   *
   * 並行性の観点:
   *   親と子の終了順も非決定的であり、毎回同じとは限らない。
   *
   * さらに実務的には:
   *   親が wait() を呼ばないと、子が先に終了したときに「ゾンビプロセス」が一時的に残ることがある。
   *   学習を進めるなら、次は親側で wait(NULL) を入れて「子の終了回収」を体験すると良い。
   */
  return 0;
}

/*
 * 実行例（fork成功時、順序は毎回変わりうる）:
 *
 *   $ ./a.out
 *   親プロセス
 *   子プロセス
 *
 * または
 *   子プロセス
 *   親プロセス
 *
 * 観察ポイント:
 *   - 2行出るのは fork() でプロセスが増えたため。
 *   - 表示順はスケジューラ次第で変わる（非決定的）。
 *
 * 注意:
 *   このコードは「親/子ラベルの表示」だけで、fork戻り値やPIDの数値は表示していない。
 *   PIDや親子関係も観察したいなら getpid()/getppid() を出力するのが次の一手である。
 */
