/*
 * 目的:
 *   fork() とプロセスの基本挙動を「観察」するための最小コードである。
 *
 *   元々は getpid() だけで「自分のPIDを表示」するだけだったが、
 *   ここでは fork() を 1 回呼ぶことで、
 *
 *     - 親プロセス（fork() を呼んだ側）
 *     - 子プロセス（fork() によって新しく作られる側）
 *
 *   の 2 つのプロセスが同じコードを同時に進むことを体験する。
 *
 * 重要:
 *   fork() は「スレッドを増やす」のではなく「プロセスを複製する」操作である。
 *   したがって、メモリ空間は分離される（ただし最初は Copy-on-Write で共有っぽく見える）。
 *
 * 観察結果としては、このプログラムを実行すると printf が 2 回走り、
 *   - 親のPID
 *   - 子のPID
 * がそれぞれ表示される。
 */

#include <sys/types.h>   /* pid_t の型定義など。
                          * pid_t は「PIDを表すための専用型」であり、環境依存の幅を持ちうる。
                          */

#include <unistd.h>      /* POSIX API:
                          * fork(), getpid(), getppid() など。
                          */

#include <stdio.h>       /* printf() 用 */

/*
 * main:
 *   親プロセスとして起動し、fork() によって子プロセスも生成される。
 *   fork() 以降のコードは「親と子の両方」が実行する点が最大のポイント。
 */
int main(void){

  /*
   * fork():
   *   現在のプロセスを「複製」して子プロセスを作る。
   *   fork() を呼んだ瞬間から、
   *     - 親プロセス
   *     - 子プロセス
   *   が存在し、両者は「fork() の次の行」からそれぞれ実行を続ける。
   *
   *   戻り値が超重要:
   *     親プロセス: 子プロセスのPID（>0）
   *     子プロセス: 0
   *     失敗       : -1（子は作られない）
   *
   *   今のコードでは戻り値を捨てているため、
   *   「親と子で分岐して挙動を変える」ことができていない。
   *   ただし最初の観察としては
   *     「printf が2回出る」
   *   を見るだけでも fork の効果は理解できる。
   *
   * 並行性の観点:
   *   親と子は「どちらが先にprintfするか」は決まっていない。
   *   スケジューラ次第で表示順が入れ替わることがある。
   */
  fork();

  /*
   * ここから下は「親プロセス」と「子プロセス」が両方実行する。
   *
   * つまり、この printf は 2 回実行される可能性が高い。
   *   1回目: 親が出力
   *   2回目: 子が出力
   * ただし順番は非決定的（毎回同じにならないことがある）。
   */

  /*
   * getpid():
   *   現在実行中プロセスの PID を返す。
   *
   * fork() 後の重要ポイント:
   *   - 親と子は別プロセスなので、getpid() の結果が異なる。
   *   - 親子関係は getppid() で観察できる。
   *     子側では getppid() が親のPIDになる。
   *
   * 型の観点:
   *   getpid() の戻り値は pid_t なので、本来は pid_t に受けるのが自然。
   *   printf の %d と型を揃えるために (int) キャストすることも多い。
   */
  printf("プロセス id=%d\n", (int)getpid());

  /*
   * 注意（バッファリング）:
   *   printf は通常 stdout に書くが、stdout は「行バッファ」になったり
   *   「フルバッファ」になったりする（端末/リダイレクトで挙動が変わる）。
   *
   *   fork の直前に printf をして改行が無い場合、
   *   バッファが複製されて「同じ内容が2回出る」事故が起きることがある。
   *
   *   今回は fork 後の printf で、かつ改行 \n があるため起きにくいが、
   *   fork と標準出力の関係は並行プログラミングで頻出の落とし穴なので覚えておく。
   */

  /*
   * return 0:
   *   正常終了。
   *   親も子もここに到達して、それぞれ独立に終了する。
   *
   * 結果:
   *   「親プロセスが終了」しても「子プロセスは別物」なので、
   *   子は子で return 0 まで走って終了する（逆も同様）。
   */
  return 0;
}

/*
 * 実行例（典型）:
 *   $ gcc -Wall -O2 pid.c -o pid
 *   $ ./pid
 *   プロセス id=12345
 *   プロセス id=12346
 *
 * 観察ポイント:
 *   - 出力が 2 行になる（= fork により2プロセスが動いた）
 *   - PID が 2 種類表示される（親と子で別PID）
 *   - 行の順序は毎回同じとは限らない（非決定性）
 *
 * さらに理解を深めるなら（次の一手）:
 *   fork() の戻り値を受けて親子で分岐し、
 *   getppid() も表示すると「親子関係」が明確になる。
 *
 *   例（概念）:
 *     pid_t pid = fork();
 *     if (pid == 0) { // child
 *         printf("child pid=%d ppid=%d\n", getpid(), getppid());
 *     } else {        // parent
 *         printf("parent pid=%d child=%d\n", getpid(), pid);
 *     }
 *
 * ※ただしここでは「詳細コメント付与」が目的なので、コード改変は最小に留めている。
 */
