/*
 * 目的:
 *   fork() やプロセスの概念を理解する前段として、
 *   「いま動いている自分自身のプロセスID(PID)を表示する」最小コードである。
 *
 * これは並行プログラミング（並行=同時に進む処理）を学ぶときの基本材料で、
 *   - プロセス（OSが管理する実行単位）
 *   - スレッド（同一プロセス内の実行単位）
 * の違いを理解する足場になる。
 *
 * このコードはまだ fork() していないので「プロセスは1つだけ」。
 * その1つのプロセスが、自分のPIDを表示して終了する。
 */

#include <sys/types.h>   /* pid_t などの型定義を提供するヘッダ
                          *
                          * 例: pid_t は「プロセスIDを格納する型」
                          *     OSや環境によって int と同じとは限らないので、
                          *     こうした専用型を使うのがCの作法。
                          */

#include <unistd.h>      /* POSIX API の宣言が多く入っているヘッダ
                          *
                          * getpid() / fork() / exec() / read() / write() など
                          * 「UNIX系OSの基本システムコール」に関係する関数がここにある。
                          *
                          * 今回は getpid() を使うので必要。
                          */

#include <stdio.h>       /* printf() を使うための標準入出力ヘッダ */

int main(void){
  /*
   * getpid():
   *   現在実行中のプロセスの PID（Process ID）を返す。
   *
   * PID とは:
   *   OSがプロセスを識別するために付ける番号。
   *   ps コマンドなどでも確認できる。
   *
   * 重要ポイント:
   *   - 同じプログラムを2回起動すれば PID は通常別になる（別プロセスだから）。
   *   - fork() すると「親プロセス」と「子プロセス」が生まれ、
   *     親と子で PID は別になる（ただし子は親PIDを getppid() で参照できる）。
   */
  printf("プロセス id=%d\n", getpid());

  /*
   * main の戻り値:
   *   Cでは main は int を返すのが基本。
   *   return 0; は「正常終了」を意味する（シェルで $? が 0 になる）。
   *
   * ※あなたの元コードは return が省略されているが、
   *   C99以降では main で return を省略すると暗黙に 0 を返す扱いになる。
   *   ただ、学習用には明示する方が分かりやすい。
   */
  return 0;
}

/*
 * 実行例:
 *   $ gcc -Wall -O2 pid.c -o pid
 *   $ ./pid
 *   プロセス id=12345
 *
 * 観察ポイント:
 *   - 何度か実行すると id が変わる
 *   - ps -o pid,ppid,cmd -p 12345 でプロセス情報を確認できる
 *
 * 次に fork() を入れると、同じ printf が「親と子の2回」出るようになる。
 * そのとき、PIDが2種類出るのが「プロセスが増えた」ことの直感的証拠になる。
 */
